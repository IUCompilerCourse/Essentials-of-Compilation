%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\itm}[1]{\ensuremath{\mathit{#1}}}
\newcommand{\ttm}[1]{\ensuremath{\text{\texttt{#1}}}}

\newcommand{\Lang}{\mathcal{L}}
\newcommand{\CLang}{\mathcal{C}}

\newcommand{\LangInt}{\ensuremath{\Lang_{\mathsf{Int}}}} % R0

\newcommand{\LangVar}{$\Lang_{\mathsf{Var}}$} % R1
\newcommand{\LangVarM}{\Lang_{\mathsf{Var}}}

\newcommand{\RCO}{\mathit{mon}} % output of remove-complex-opera*

\newcommand{\LangVarANF}{\ensuremath{\Lang^{\RCO}_{\mathsf{Var}}}}
\newcommand{\LangVarANFM}{\Lang^{\RCO}_{\mathsf{Var}}}

\newcommand{\LangIf}{$\Lang_{\mathsf{If}}$} %R2
\newcommand{\LangIfM}{\ensuremath{\Lang_{\mathsf{If}}}} %R2
\newcommand{\LangIfANF}{\ensuremath{\Lang^{\RCO}_{\mathsf{if}}}} %R2

\newcommand{\LangCVar}{$\CLang_{\mathsf{Var}}$} % C0
\newcommand{\LangCVarM}{\CLang_{\mathsf{Var}}} % C0
\newcommand{\LangCIf}{$\CLang_{\mathsf{If}}$} %C1
\newcommand{\LangCIfM}{\ensuremath{\CLang_{\mathsf{If}}}} %C1
\newcommand{\LangVec}{$\Lang_{\mathsf{Tup}}$} %R3
\newcommand{\LangVecM}{\Lang_{\mathsf{Tup}}} %R3
\newcommand{\LangStruct}{\ensuremath{\Lang_{\mathsf{Struct}}}} %\Lang^s3
\newcommand{\LangCVec}{$\CLang_{\mathsf{Tup}}$} %C2
\newcommand{\LangCVecM}{\CLang_{\mathsf{Tup}}} %C2
\newcommand{\LangVecANF}{\ensuremath{\Lang^{\RCO}_{\mathsf{Tup}}}} %R3
\newcommand{\LangVecANFM}{\Lang^{\RCO}_{\mathsf{Tup}}} %R3
\newcommand{\LangAlloc}{\ensuremath{\Lang_{\mathsf{Alloc}}}} %R3'
\newcommand{\LangAllocANF}{\ensuremath{\Lang^{\RCO}_{\mathsf{Alloc}}}} %R3'
\newcommand{\LangAllocANFM}{\Lang^{\RCO}_{\mathsf{Alloc}}} %R3'
\newcommand{\LangFun}{$\Lang_{\mathsf{Fun}}$} %R4
\newcommand{\LangFunM}{\Lang_{\mathsf{Fun}}} %R4
\newcommand{\LangCFun}{$\CLang_{\mathsf{Fun}}$} %C3
\newcommand{\LangCFunM}{\CLang_{\mathsf{Fun}}} %C3
\newcommand{\LangFunANF}{\ensuremath{\Lang^{\RCO}_{\mathsf{FunRef}}}} %R4
\newcommand{\LangFunRef}{$\Lang_{\mathsf{FunRef}}$} %F1
\newcommand{\LangFunRefM}{\Lang_{\mathsf{FunRef}}} %F1
\newcommand{\LangFunRefAlloc}{\ensuremath{\Lang^{\mathsf{Alloc}}_{\mathsf{FunRef}}}} %R'4
\newcommand{\LangLam}{$\Lang_\lambda$} %R5
\newcommand{\LangLamFunRef}{$\Lang_\lambda^{\mathsf{FunRef}}$} 
\newcommand{\LangLamM}{\ensuremath{\Lang_\lambda}} %R5
\newcommand{\LangCLam}{$\CLang_{\mathsf{Clos}}$} %C4
\newcommand{\LangCLamM}{\CLang_{\mathsf{Clos}}} %C4
\newcommand{\LangAny}{$\Lang_{\mathsf{Any}}$} %R6
\newcommand{\LangAnyM}{\Lang_{\mathsf{Any}}} %R6
\newcommand{\LangAnyFunRef}{\ensuremath{\Lang^{\mathsf{FunRef}}_{\mathsf{Any}}}} %R'6
\newcommand{\LangAnyAlloc}{\ensuremath{\Lang^{\mathsf{Alloc}}_{\mathsf{Any}}}} %R'6
\newcommand{\LangCAny}{$\CLang_{\mathsf{Any}}$} %C5
\newcommand{\LangCAnyM}{\CLang_{\mathsf{Any}}} %C5
\newcommand{\LangDyn}{$\Lang_{\mathsf{Dyn}}$} %R7
\newcommand{\LangDynM}{\Lang_{\mathsf{Dyn}}} %R7
\newcommand{\LangDynFunRef}{\ensuremath{\Lang^{\mathsf{FunRef}}_{\mathsf{Dyn}}}} %R'7
\newcommand{\LangLoop}{$\Lang_{\mathsf{While}}$} %R8
\newcommand{\LangLoopM}{\Lang_{\mathsf{While}}} %R8
\newcommand{\LangLoopFunRef}{\ensuremath{\Lang^{\mathsf{FunRef}}_{\mathsf{While}}}} %R'8
\newcommand{\LangLoopAlloc}{\ensuremath{\Lang^{\mathsf{Alloc}}_{\mathsf{While}}}} %R'8
\newcommand{\LangCLoop}{$\CLang_{\circlearrowleft}$} %C7
\newcommand{\LangCLoopM}{\CLang_{\circlearrowleft}} %C7
\newcommand{\LangLoopANF}{\ensuremath{\Lang^{\RCO}_{\mathsf{While}}}} %R8
\newcommand{\LangArray}{\ensuremath{\Lang^{\mathsf{Vecof}}_{\mathsf{While}}}} %\Lang^s3
\newcommand{\LangGrad}{$\Lang_{\mathsf{?}}$} %R9
\newcommand{\LangGradM}{\Lang_{\mathsf{?}}} %R9
\newcommand{\LangCast}{$\Lang_{\mathsf{cast}}$} %R9'
\newcommand{\LangCastM}{\Lang_{\mathsf{cast}}} %R9'
\newcommand{\LangProxy}{\ensuremath{\Lang_{\mathsf{proxy}}}} %R8''
\newcommand{\LangPVec}{\ensuremath{\Lang_{\mathsf{PVec}}}} %R8''
\newcommand{\LangPVecFunRef}{\ensuremath{\Lang^{\mathsf{FunRef}}_{\mathsf{PVec}}}} %R8''
\newcommand{\LangPVecAlloc}{\ensuremath{\Lang^{\mathsf{Alloc}}_{\mathsf{PVec}}}} %R8''
\newcommand{\LangPoly}{\ensuremath{\Lang_{\mathsf{Poly}}}} %R10
\newcommand{\LangInst}{\ensuremath{\Lang_{\mathsf{Inst}}}} %R'10
\newcommand{\LangCLoopPVec}{\ensuremath{\CLang^{\mathsf{PVec}}_{\circlearrowleft}}} %Cp7

\newcommand{\LangXVar}{$\mathrm{x86}_{\mathsf{Var}}$} % pseudo x86_0
\newcommand{\LangXASTInt}{\ensuremath{\mathrm{x86}_{\mathsf{Int}}}} % x86_0
\newcommand{\LangXInt}{$\mathrm{x86}_{\mathsf{Int}}$} %x86^{\dagger}_0
\newcommand{\LangXIntM}{\mathrm{x86}_{\mathsf{Int}}} %x86^{\dagger}_0
\newcommand{\LangXASTIf}{\ensuremath{\mathrm{x86}_{\mathsf{If}}}} %x86_1
\newcommand{\LangXIf}{$\mathrm{x86}_{\mathsf{If}}$} %x86^{\dagger}_1
\newcommand{\LangXIfM}{\mathrm{x86}_{\mathsf{If}}} %x86^{\dagger}_1
\newcommand{\LangXIfVar}{\ensuremath{\mathrm{x86}^{\mathsf{Var}}_{\mathsf{If}}}} %x86^{*}_1
\newcommand{\LangXASTGlobal}{\ensuremath{\mathrm{x86}_{\mathsf{Global}}}} %x86_2
\newcommand{\LangXGlobal}{$\mathrm{x86}_{\mathsf{Global}}$} %x86^{\dagger}_2
\newcommand{\LangXGlobalM}{\mathrm{x86}_{\mathsf{Global}}} %x86^{\dagger}_2
\newcommand{\LangXGlobalVar}{\ensuremath{\mathrm{x86}^{\mathsf{Var}}_{\mathsf{Global}}}} %x86^{*}_2
\newcommand{\LangXIndCall}{$\mathrm{x86}_{\mathsf{callq*}}$} %x86_3
\newcommand{\LangXIndCallM}{\mathrm{x86}_{\mathsf{callq*}}} %x86_3
\newcommand{\LangXIndCallVar}{\ensuremath{\mathrm{x86}^{\mathsf{Var}}_{\mathsf{callq*}}}} %x86^*_3

\newcommand{\Stmt}{\itm{stmt}}
\newcommand{\Exp}{\itm{exp}}
\newcommand{\Def}{\itm{def}}
\newcommand{\Type}{\itm{type}}
\newcommand{\FType}{\itm{ftype}}
\newcommand{\Instr}{\itm{instr}}
\newcommand{\Block}{\itm{block}}
\newcommand{\Tail}{\itm{tail}}
\newcommand{\Prog}{\itm{prog}}
\newcommand{\Arg}{\itm{arg}}
\newcommand{\Atm}{\itm{atm}}
\newcommand{\Reg}{\itm{reg}}
\newcommand{\Int}{\itm{int}}
\newcommand{\Var}{\itm{var}}
\newcommand{\Op}{\itm{op}}
\newcommand{\key}[1]{\texttt{#1}}
\newcommand{\code}[1]{\texttt{#1}}

\newcommand{\LP}{\key{(}}
\newcommand{\RP}{\key{)}}
\newcommand{\LS}{\key{[}}
\newcommand{\RS}{\key{]}}
\newcommand{\LC}{\key{\{}}
\newcommand{\RC}{\key{\}}}

\newcommand{\MID}{\;\;\mid\;\;}

\if\edition\racketEd
\newcommand{\INT}[1]{{\key{(Int}~#1\key{)}}}
\newcommand{\READOP}{{\key{read}}}
\newcommand{\READ}{{\key{(Prim}~\code{read}~\key{())}}}
\newcommand{\CREAD}{\key{(read)}}
\newcommand{\NEG}[1]{{\key{(Prim}~\code{-}~\code{(}#1\code{))}}}
\newcommand{\ADD}[2]{{\key{(Prim}~\code{+}~\code{(}#1~#2\code{))}}}
\newcommand{\SUB}[2]{\key{(Prim}~\code{-}~\code{(}#1~#2\code{))}}
\newcommand{\PROGRAM}[2]{\LP\code{Program}~#1~#2\RP}
\newcommand{\VAR}[1]{\key{(Var}~#1\key{)}}
\newcommand{\BOOL}[1]{\key{(Bool}~#1\key{)}}
\newcommand{\TRUE}{\key{\#t}}
\newcommand{\FALSE}{\key{\#f}}
\newcommand{\UNIOP}[2]{\key{(Prim}~#1~\code{(}#2\code{))}}
\newcommand{\CUNIOP}[2]{\LP #1~#2 \RP}
\newcommand{\BINOP}[3]{\key{(Prim}~#1~\code{(}#2~#3\code{))}}
\newcommand{\CBINOP}[3]{\LP #1~#2~#3\RP}
\newcommand{\CEQ}[2]{\LP\key{eq?}~#1~#2\RP}
\newcommand{\IF}[3]{\key{(If}\,#1~#2~#3\key{)}}
\newcommand{\CIF}[3]{\LP\key{if}~#1~#2~#3\RP}
\newcommand{\AND}[2]{\key{(Prim}~\code{and}~\code{(}#1~#2\code{))}}
\newcommand{\OR}[2]{\key{(Prim}~\code{or}~\code{(}#1~#2\code{))}}
\newcommand{\CAND}[2]{\CBINOP{\key{and}}{#1}{#2}}
\newcommand{\COR}[2]{\CBINOP{\key{or}}{#1}{#2}}
\newcommand{\INTTY}{{\key{Integer}}}
\newcommand{\BOOLTY}{{\key{Boolean}}}
\newcommand{\VECTY}[1]{{\LP\key{Vector}#1\RP}}
\newcommand{\CPROGRAM}[2]{\LP\code{CProgram}~#1~#2\RP}
\newcommand{\CPROGRAMDEFS}[2]{\LP\code{CProgramDefs}~#1~#2\RP}
\newcommand{\LET}[3]{\key{(Let}~#1~#2~#3\key{)}}
\newcommand{\CLET}[3]{\LP\key{let}~\LP\LS#1~#2\RS\RP~#3\RP}
\newcommand{\COLLECT}[1]{\LP\key{Collect}~#1\RP}
\newcommand{\CCOLLECT}[1]{\LP\key{collect}~#1\RP}
\newcommand{\ALLOCATE}[2]{\LP\key{Allocate}~#1~#2\RP}
\newcommand{\CALLOCATE}[2]{\LP\key{allocate}~#1~#2\RP}
\newcommand{\GLOBAL}[1]{\LP\key{Global}~#1\RP}
\newcommand{\CGLOBAL}[1]{#1\key{(\%rip)}}
\newcommand{\GLOBALVALUE}[1]{\LP\key{GlobalValue}~#1\RP}
\newcommand{\CGLOBALVALUE}[1]{\LP\key{global-value}~#1\RP}
\fi

\if\edition\pythonEd
\newcommand{\LET}[3]{\key{Let}\LP #1 \key{,} #2 \key{,} #3 \RP}
\newcommand{\CLET}[3]{\key{let}~#1~\key{=}~#2~\key{in}~#3}
\newcommand{\INT}[1]{{\key{Constant}\LP#1\RP}}
\newcommand{\READOP}{{\key{input\_int}}}
\newcommand{\READ}{{\key{Call(Name('input\_int'),[])}}}
\newcommand{\CREAD}{\key{input\_int()}}
\newcommand{\NEG}[1]{{\key{UnaryOp(USub(),} #1\code{)}}}
\newcommand{\ADD}[2]{{\key{BinOp}\LP #1\code{,} \key{Add()}\key{,}#2\code{)}}}
\newcommand{\SUB}[2]{{\key{BinOp}\LP \key{Sub()}\key{,}#1\code{,}#2\code{)}}}
\newcommand{\PRINT}[1]{{\key{Expr}\LP\key{Call}\LP\key{Name}\LP\key{'print'}\RP\key{,}\LS#1\RS\RP\RP}}
\newcommand{\CPRINT}[1]{\key{print}\LP #1\RP}
\newcommand{\EXPR}[1]{{\key{Expr}\LP #1\RP}}
\newcommand{\PROGRAM}[2]{\code{Module}\LP #2\RP}
\newcommand{\CPROGRAM}[2]{\code{CProgram}\LP #2 \RP}
\newcommand{\CPROGRAMDEFS}[1]{\code{CProgramDefs}\LP #1 \RP}
\newcommand{\VAR}[1]{\key{Name}\LP #1\RP}
\newcommand{\BOOL}[1]{\key{Constant}\LP #1 \RP}
\newcommand{\UNIOP}[2]{\key{UnaryOp}\LP #1 \code{,} #2 \RP}
\newcommand{\CUNIOP}[2]{#1~#2}
\newcommand{\BINOP}[3]{\key{BinOp}\LP #1 \code{,} #2 \code{,} #3 \RP}
\newcommand{\CBINOP}[3]{#2~#1~#3}
\newcommand{\CEQ}[2]{#1~\code{==}~#2}
\newcommand{\CGET}[2]{#1 \LS #2 \RS}
\newcommand{\GET}[2]{\key{Subscript}\LP #1 \code{,} #2 \code{,} \code{Load()} \RP}
\newcommand{\CLEN}[1]{\code{len}\LP #1 \RP}
\newcommand{\LEN}[1]{\code{Call}\LP \code{Name('len')} \code{,} \LS #1 \RS \RP}
\newcommand{\PUT}[2]{\key{Subscript}\LP #1 \code{,} #2 \code{,} \code{Store()} \RP}
\newcommand{\TUPLE}[1]{\key{Tuple}\LP #1 \code{,} \code{Load()} \RP}
\newcommand{\BOOLOP}[3]{\key{BoolOp}\LP #1 \code{,} \LS #2 \code{,} #3 \RS \RP}
\newcommand{\CMP}[3]{\key{Compare}\LP #1\code{,}\LS #2 \RS \code{,} \LS #3 \RS\RP}
\newcommand{\CCMP}[3]{#2~#1~#3}
\newcommand{\TRUE}{\key{True}}
\newcommand{\FALSE}{\key{False}}
\newcommand{\IF}[3]{\key{IfExp}\LP #1 \code{,} #2 \code{,} #3 \RP}
\newcommand{\CIF}[3]{#2~\key{if}~#1~\key{else}~#3}
\newcommand{\AND}[2]{\BOOLOP{\key{And()}}{#1}{#2}}
\newcommand{\CAND}[2]{#1~\key{and}~#2}
\newcommand{\OR}[2]{\BOOLOP{\key{Or()}}{#1}{#2}}
\newcommand{\COR}[2]{#1~\key{or}~#2}
\newcommand{\INTTY}{{\key{int}}}
\newcommand{\BOOLTY}{{\key{bool}}}
\newcommand{\VECTY}[1]{{\key{TupleType}\LP\LS #1 \RS\RP}}
\newcommand{\COLLECT}[1]{\key{Collect}\LP#1\RP}
\newcommand{\CCOLLECT}[1]{\key{collect}\LP#1\RP}
\newcommand{\ALLOCATE}[2]{\key{Allocate}\LP#1,#2\RP}
\newcommand{\CALLOCATE}[2]{\key{allocate}\LP#1,#2\RP}
\newcommand{\GLOBALVALUE}[1]{\key{GlobalValue}\LP#1\RP}
\newcommand{\CGLOBALVALUE}[1]{\key{global\_value}\LP#1\RP}
\newcommand{\GLOBAL}[1]{\key{Global}\LP#1\RP}
\newcommand{\CGLOBAL}[1]{#1\LP\key{\%rip}\RP}
\newcommand{\CNEG}[1]{\key{-}~#1}
\newcommand{\CNOT}[1]{\key{not}~#1}
\newcommand{\CALL}[2]{\key{Call}\LP#1\code{, }#2\RP}
\newcommand{\APPLY}[2]{\key{Call}\LP#1\code{, }#2\RP}
\newcommand{\CAPPLY}[2]{#1\LP#2\RP}
\newcommand{\FUNREF}[1]{\key{FunRef}\LP#1\RP}
\newcommand{\CFUNREF}[1]{#1\code{(\%rip)}}
\fi % pythonEd

\if\edition\racketEd
\newcommand{\BEGIN}[2]{\LP\key{Begin}~#1~#2\RP}
\newcommand{\CBEGIN}[2]{\LP\key{begin}~#1~#2\RP}
\newcommand{\CNEG}[1]{\LP\key{-}~#1\RP}
\newcommand{\CNOT}[1]{\LP\key{not}~#1\RP}
\newcommand{\CALL}[2]{\key{Call}\LP #1\code{, } #2 \RP}
\newcommand{\APPLY}[2]{\key{(Apply}~#1~#2\code{)}}
\newcommand{\CAPPLY}[2]{\LP~#1~#2\RP}
\newcommand{\FUNREF}[1]{\LP\key{FunRef}~#1\RP}
\newcommand{\CFUNREF}[1]{\key{(fun-ref}~#1\code{)}}
\fi
\newcommand{\PRIM}[2]{\LP\key{Prim}~#1~\LP #2\RP\RP}
\newcommand{\PROGRAMDEFSEXP}[3]{\code{(ProgramDefsExp}~#1~#2~#3\code{)}}
\newcommand{\PROGRAMDEFS}[2]{\code{(ProgramDefs}~#1~#2\code{)}}
\newcommand{\CADD}[2]{\LP\key{+}~#1~#2\RP}
\newcommand{\CMUL}[2]{\LP\key{*}~#1~#2\RP}
\newcommand{\CSUB}[2]{\LP\key{-}~#1~#2\RP}
\newcommand{\CWHILE}[2]{\LP\key{while}~#1~#2\RP}
\newcommand{\WHILE}[2]{\LP\key{WhileLoop}~#1~#2\RP}
\newcommand{\CMAKEVEC}[2]{\LP\key{make-vector}~#1~#2\RP}
\newcommand{\CSETBANG}[2]{\LP\key{set!}~#1~#2\RP}
\newcommand{\SETBANG}[2]{\LP\key{SetBang}~#1~#2\RP}
\newcommand{\GETBANG}[1]{\LP\key{GetBang}~#1\RP}
\newcommand{\NOT}[1]{\key{(Prim}~\code{not}~\code{(}#1~\code{))}}
\newcommand{\CAST}[3]{\LP\key{Cast}~#1~#2~#3\RP}
\newcommand{\VECTOR}[1]{\LP\key{Prim}~\code{vector}~\LP~#1\RP\RP}
\newcommand{\VECREF}[2]{\LP\key{Prim}~\code{vector-ref}~\LP #1~#2\RP\RP}
\newcommand{\VECSET}[3]{\LP\key{Prim}~\code{vector-set!}~\LP #1~#2~#3\RP\RP}
\newcommand{\VECLEN}[1]{\LP\key{Prim}~\code{vector-length}~\LP #1\RP\RP}
\newcommand{\ANYVECREF}[2]{\LP\key{Prim}~\code{any-vector-ref}~\LP #1~#2\RP\RP}
\newcommand{\ANYVECSET}[3]{\LP\key{Prim}~\code{any-vector-set!}~\LP #1~#2~#3\RP\RP}
\newcommand{\ANYVECLEN}[1]{\LP\key{Prim}~\code{any-vector-length}~\LP #1\RP\RP}
\newcommand{\CLOSURE}[2]{\LP\key{Closure}~#1~#2\RP}
\newcommand{\ALLOC}[2]{\LP\key{Allocate}~#1~#2\RP}
\newcommand{\ALLOCCLOS}[3]{\LP\key{AllocateClosure}~#1~#2~#3\RP}

\newcommand{\VOID}[1]{\key{(Void)}}
\newcommand{\FUNREFARITY}[2]{\key{(FunRefArity}~#1~#2\code{)}}
\newcommand{\CFUNREFARITY}[2]{\key{(fun-ref-arity}~#1~#2\code{)}}
\newcommand{\CGLAMBDA}[3]{\LP\key{lambda:}\,#1\,#2~\Exp\RP}
\newcommand{\INJECT}[2]{\LP\key{Inject}~#1~#2\RP}
\newcommand{\PROJECT}[2]{\LP\key{Project}~#1~#2\RP}
\newcommand{\CINJECT}[2]{\LP\key{inject}~#1~#2\RP}
\newcommand{\CPROJECT}[2]{\LP\key{project}~#1~#2\RP}
\newcommand{\VALUEOF}[2]{\LP\key{ValueOf}~#1~#2\RP}

\if\edition\racketEd
\newcommand{\LAMBDA}[3]{\key{(Lambda}~#1~#2~#3\code{)}}
\newcommand{\CLAMBDA}[3]{\LP\key{lambda:}\,#1\,\key{:}\,#2~\Exp\RP}
\newcommand{\TAILCALL}[2]{\key{(TailCall}~#1~#2\code{)}}
\newcommand{\CASSIGN}[2]{#1~\key{=}~#2\key{;}}
\newcommand{\ASSIGN}[2]{\key{(Assign}~#1~#2\key{)}}
\newcommand{\IFSTMT}[3]{\key{(IfStmt}\,#1~#2~#3\key{)}}
\newcommand{\RETURN}[1]{\key{(Return}~#1\key{)}}
\newcommand{\CRETURN}[1]{\key{return}~#1\key{;}}
\newcommand{\GOTO}[1]{\key{(Goto}~#1\key{)}}
\newcommand{\CGOTO}[1]{\key{goto}~#1\key{;}}
\newcommand{\FUNDEF}[5]{\key{(Def}~#1~#2~#3~#4~#5\code{)}}
\fi
\if\edition\pythonEd
\newcommand{\LAMBDA}[2]{\key{Lambda}\LP#1\key{, }#2\RP}
\newcommand{\CLAMBDA}[2]{\key{lambda}\,#1\,\key{:}\,#2}
\newcommand{\TAILCALL}[2]{\key{TailCall}\LP#1\code{,}#2\RP}
\newcommand{\CASSIGN}[2]{#1~\key{=}~#2}
\newcommand{\ASSIGN}[2]{\key{Assign}\LP\LS #1\RS\key{, }#2\RP}
\newcommand{\IFSTMT}[3]{\key{If}\LP #1 \code{, } #2 \code{, } #3 \RP}
\newcommand{\CIFSTMT}[3]{\key{if}~#1\code{:}~#2~\code{else:}~#3}
\newcommand{\CBEGIN}[2]{\key{begin:}~#1~#2}
\newcommand{\BEGIN}[2]{\key{Begin}\LP#1\code{, }#2\RP}
\newcommand{\WHILESTMT}[2]{\key{While}\LP #1 \code{, } #2 \code{, []}\RP}
\newcommand{\RETURN}[1]{\key{Return}\LP #1 \RP}
\newcommand{\CRETURN}[1]{\key{return}~#1}
\newcommand{\GOTO}[1]{\key{Goto}\LP #1 \RP}
\newcommand{\CGOTO}[1]{\key{goto}~#1}
\newcommand{\FUNDEF}[5]{\key{FunctionDef}\LP#1\key{, }#2\key{, }#3\key{, }#5\RP}
\fi

\newcommand{\SEQ}[2]{\key{(Seq}~#1~#2\key{)}}

\if\edition\racketEd
\newcommand{\IMM}[1]{\key{(Imm}~#1\key{)}}
\newcommand{\REG}[1]{\key{(Reg}~#1\key{)}}
\newcommand{\DEREF}[2]{\key{(Deref}~#1~#2\key{)}}
\newcommand{\BININSTR}[3]{\key{(Instr}~#1~\key{(}#2~#3\key{))}}
\newcommand{\UNIINSTR}[2]{\key{(Instr}~#1~\key{(}#2\key{))}}
\newcommand{\CALLQ}[2]{\key{(Callq}~#1~#2\key{)}}
\newcommand{\PUSHQ}[1]{\key{(Pushq}~#1\key{)}}
\newcommand{\POPQ}[1]{\key{(Popq}~#1\key{)}}
\newcommand{\JMP}[1]{\key{(Jmp}~#1\key{)}}
\newcommand{\JMPIF}[2]{\key{(JmpIf}~#1~#2\key{)}}
\newcommand{\RETQ}{\key{(Retq)}}
\newcommand{\XPROGRAM}[2]{\LP\code{X86Program}~#1~#2\RP}
\newcommand{\BYTEREG}[1]{\key{(ByteReg}~#1\key{)}}
\newcommand{\CDEF}[4]{\LP\key{define}~\LP#1~#2\RP\,\key{:}\,#3~#4\RP}
\newcommand{\DEF}[5]{\LP\key{Def}~#1~#2~#3~#4~#5\RP}
\newcommand{\INDCALLQ}[2]{\key{(IndirectCallq}~#1~#2\key{)}}
\newcommand{\TAILJMP}[2]{\key{(TailJmp}~#1~#2\key{)}}
\fi
\if\edition\pythonEd
\newcommand{\TAILJMP}[2]{\key{TailJmp}\LP#1\code{, }#2\RP}
\newcommand{\INDCALLQ}[2]{\key{IndirectCallq}\LP#1\code{, }#2\RP}
\newcommand{\IMM}[1]{\key{Immediate}\LP #1\RP}
\newcommand{\REG}[1]{\key{Reg}\LP #1\RP}
\newcommand{\DEREF}[2]{\key{Deref}\LP #1 \key{,} #2 \RP}
\newcommand{\BININSTR}[3]{\key{Instr}\LP #1 \key{,} \LS #2 \key{,} #3 \RS \RP}
\newcommand{\UNIINSTR}[2]{\key{Instr}\LP #1 \key{,} \LS #2 \RS \RP}
\newcommand{\CALLQ}[2]{\key{Callq}\LP #1 \key{,} #2 \RP}
\newcommand{\PUSHQ}[1]{\key{Instr}\LP \code{pushq} \key{,} \LS #1 \RS \RP}
\newcommand{\POPQ}[1]{\key{Instr}\LP \code{popq} \key{,} \LS #1 \RS \RP}
\newcommand{\JMP}[1]{\key{Jump}\LP #1 \RP}
\newcommand{\JMPIF}[2]{\key{JumpIf}\LP #1 \key{,} #2 \RP}
\newcommand{\RETQ}{\key{Retq}\LP\RP}
% TODO: change \XPROGRAM to 1 parameter
\newcommand{\XPROGRAM}[2]{\code{X86Program}\LP #2 \RP}
\newcommand{\XPROGRAMDEFS}[1]{\code{X86ProgramDefs}\LP #1 \RP}
\newcommand{\BYTEREG}[1]{\key{ByteReg}\LP #1 \RP}
\newcommand{\CDEF}[4]{\key{def}~#1\LP #2 \RP ~\key{->}~ #3 \key{:}~#4}
\newcommand{\DEF}[6]{\key{FunctionDef}\LP#1\key{, }#2\key{, }#3\key{, }#4\key{, }#5\key{, }#6\RP}
\fi



\newcommand{\CGDEF}[4]{\LP\key{define}~\LP#1~#2\RP\,#3~#4\RP}
\newcommand{\DECL}[2]{\LP\key{Decl}~#1~#2\RP}
\newcommand{\INST}[3]{\LP\key{Inst}~#1~#2~#3\RP}
\newcommand{\CFG}[1]{\key{(CFG}~#1\key{)}}
\newcommand{\BLOCK}[2]{\key{(Block}~#1~#2\key{)}}
\newcommand{\STACKLOC}[1]{(\key{stack}~#1)}



\newcommand{\TTKEY}[1]{{\normalfont\tt #1}}

\newenvironment{transformation}{
  \newcommand{\compilesto}{%
    \end{minipage}&$\Rightarrow$&\begin{minipage}{0.4\textwidth}}
  \begin{center}\begin{tabular}{lll}\begin{minipage}{0.4\textwidth}
  }{%
  \end{minipage}\end{tabular}\end{center}%
}
